package com.dvf.ucst.utils.pickybuild;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Used to generate all possible [PickyBuild]s (which inherently have no conflicts).
 *
 * @param <T> The type of items contained in generated [PickyBuild]s.
 */
public final class PickyBuildGenerator<T extends PickyBuildElement<T>> {

    private final PickyBuild<T> templateBuild;
    private final List<Set<T>> clauses; // unmodifiable
    private final int numClauses;

    /**
     * @param templateBuild All [PickyBuild]s in the collection returned from the
     *     [generateAllFullPickyBuilds] operation will be supersets of [templateBuild]
     *     that are safely type-cast-able to the runtime type of [templateBuild] as
     *     is guaranteed by the [PickyBuild.copy] method spec.
     * @param conjunctiveNormalFormed An AND of OR's. Each OR clause represents items
     *     of which exactly one must be included in each [PickyBuild] generated by
     *     [generateAllFullPickyBuilds]. This field initializer is not defensively
     *     copied, so this collection's clauses, and any enclosed [T] items must not
     *     be modified after being passed to this constructor. Each entry in this
     *     collection is a 'clause.
     *   - It is allowed for clauses to have shared items (using == comparison).
     *       See spec of [PickyBuild::addIfNoConflicts] for handling of such situations.
     *   - Empty clauses are allowed and will be ignored.
     *   - [conjunctiveNormalFormed] must not be [null]. If empty, then generating
     *       builds will return [templateBuild] directly.
     */
    public PickyBuildGenerator(
            final PickyBuild<T> templateBuild,
            final Set<Set<T>> conjunctiveNormalFormed) {
        this.templateBuild = templateBuild;
        this.clauses = Collections.unmodifiableList(conjunctiveNormalFormed.stream()
                .filter(clause -> !clause.isEmpty()) // ignore empty clauses.
                .filter(clause -> !templateBuild.containsAny(clause)) // filter out satisfied clauses to defend from infinite loops
                .map(Collections::unmodifiableSet) // don't trust anybody- not even yourself.
                .sorted(Comparator.comparingInt(Set::size)) // order more-restrictive clauses first.
                .collect(Collectors.toList())
        );
        this.numClauses = clauses.size();
    }

    /**
     * @return An unmodifiable [Set]. Never [null]. See constructor spec.
     */
    public Set<PickyBuild<T>> generateAllFullPickyBuilds() {
        return (clauses.isEmpty())
                ? Set.of(templateBuild)
                : Collections.unmodifiableSet(recursiveGenerateBuilds(0, Set.of(templateBuild)))
                ;
    }

    /**
     * @param clauseIdx The index of the clause in [.clauses] to add options from to
     *     all [PickyBuild]s collected so far in [soFar].
     * @param soFar All [PickyBuild]s containing one option from each clause in
     *     [clauses] from index zero to index [clauseIdx] EXCLUSIVE. Is not modified
     *     by this operation in any way, and is no longer needed after this operation.
     * @return All [PickyBuild]s containing one option from each clause in [clauses]
     *     from index zero to index [clauseIdx] INCLUSIVE. Important conceptual note:
     *     the size of [PickyBuild]s in the returned collection will not necessarily
     *     have incremented from the [PickyBuild] they were copied from. See the note
     *     for [PickyBuild::addIfNoConflicts] on adding duplicates.
     */
    private Set<PickyBuild<T>> recursiveGenerateBuilds(final int clauseIdx, final Set<PickyBuild<T>> soFar) {
        if (soFar.size() == 0 || clauseIdx == numClauses) {
            return soFar;
        }
        final Set<PickyBuild<T>> newSoFar = new HashSet<>();

        // for each build from the previous recursive operation that might
        // not yet have an element from the clause for this recursive step,
        for (PickyBuild<T> buildInProgress : soFar) {

            // with each element from the clause for this recursive step,
            for (T optionFromNextClause : clauses.get(clauseIdx)) {
                final PickyBuild<T> optionCopy = buildInProgress.copy();

                // try adding that element to that build,
                if (optionCopy.addIfNoConflicts(optionFromNextClause)) {

                    // and if that build accepts that element, hold
                    // on to that build for the next recursive step.
                    newSoFar.addAll(new PickyBuildGenerator<>(
                            optionCopy, // <- the build with that element
                            optionFromNextClause.getPickyBuildFriends() // <- make sure it has its friends.
                    ).generateAllFullPickyBuilds());
                }
            }
        }
        return recursiveGenerateBuilds(clauseIdx + 1, newSoFar);
    }

}
