package org.bse.utils.pickybuild;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Used to generate all possible [PickyBuild]s (which inherently have no conflicts).
 *
 * @param <T> The type of items contained in generated [PickyBuild]s.
 */
public final class PickyBuildGenerator<T extends PickyBuildElement<T>> {

    private final PickyBuild<T> templateBuild;
    private final List<Set<T>> clauses; // unmodifiable
    private final int numClauses;

    /**
     * @param templateBuild All [PickyBuild]s in the collection returned from the
     *     [generateAllFullPickyBuilds] operation will be supersets of [templateBuild]
     *     that are safely type-cast-able to the runtime type of [templateBuild] as
     *     is guaranteed by the [PickyBuild.copy] method spec.
     * @param conjunctiveNormalFormed An AND of OR's. Each OR clause represents items
     *     of which exactly one must be included in each [PickyBuild] generated by
     *     [generateAllFullPickyBuilds]. This field initializer is not defensively
     *     copied, so this collection's clauses, and any enclosed [T] items must not
     *     be modified after being passed to this constructor. Each entry in this
     *     collection is a 'clause. It is allowed for any two clauses to have shared
     *     items (using address-based equality comparison). See spec of [PickyBuild::
     *     addIfNoConflicts] for handling of such situations. Empty clauses are allowed
     *     and will be ignored.
     */
    public PickyBuildGenerator(
            final PickyBuild<T> templateBuild,
            final Set<Set<T>> conjunctiveNormalFormed) {
        this.templateBuild = templateBuild;
        this.clauses = Collections.unmodifiableList(
                conjunctiveNormalFormed.stream()
                        .map(Collections::unmodifiableSet)
                        .sorted(Comparator.comparingInt(Set::size))
                        .collect(Collectors.toList())
        );
        this.numClauses = clauses.size();
    }

    /**
     * TODO [test][PickyBuildGenerator]:
     *
     * @return Never [null]. See constructor spec.
     */
    public Set<PickyBuild<T>> generateAllFullPickyBuilds() {
        return recursiveGenerateBuilds(0, Set.of(templateBuild));
    }

    /**
     * @param clauseIdx The index of the clause in [.clauses] to add options from to
     *     all [PickyBuild]s collected so far in [soFar].
     * @param soFar All [PickyBuild]s containing one option from each clause in
     *     [clauses] from index zero to index [clauseIdx] EXCLUSIVE. Is not modified
     *     by this operation in any way, and is no longer needed after this operation.
     * @return All [PickyBuild]s containing one option from each clause in [clauses]
     *     from index zero to index [clauseIdx] INCLUSIVE. Important conceptual note:
     *     the size of [PickyBuild]s in the returned collection will not necessarily
     *     have incremented from the [PickyBuild] they were copied from. See the note
     *     for [PickyBuild::addIfNoConflicts] on adding duplicates.
     */
    private Set<PickyBuild<T>> recursiveGenerateBuilds(final int clauseIdx, final Set<PickyBuild<T>> soFar) {
        if (soFar.size() == 0 || clauseIdx == numClauses) {
            return soFar;
        }
        final Set<PickyBuild<T>> newSoFar = new HashSet<>();

        // for each build from the previous recursive operation that might
        // not yet have an element from the clause for this recursive step,
        for (PickyBuild<T> buildInProgress : soFar) {

            // with each element from the clause for this recursive step,
            for (T optionFromNextClause : clauses.get(clauseIdx)) {
                final PickyBuild<T> optionCopy = buildInProgress.copy();

                // try adding that element to that build,
                if (optionCopy.addIfNoConflicts(optionFromNextClause)) {

                    // and if that build accepts that element, hold
                    // on to that build for the next recursive step.
                    newSoFar.add(optionCopy);
                }
            }
        }
        return recursiveGenerateBuilds(clauseIdx + 1, newSoFar);
    }

}
